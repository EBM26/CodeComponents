<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
	<meta name="format-detection" content="telephone=no">
	<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Work+Sans" rel="stylesheet">
	<link rel="icon" type="image/x-icon" href="mp-favicon.ico" />
	<title>Eyal's Javascript Notes</title>
	<style>
		*{margin: 0; padding: 0; max-width: 100%; -webkit-backface-visibility: hidden;}
		body{font-size: 19px; font-weight: 300; background-color: #fff;  color: #000; font-family: 'Open Sans', sans-serif; letter-spacing: .5px;}
		li{list-style-type: none;}
		div{display: block; margin: 0; padding: 0; box-sizing: border-box;}
		img{border: 0;}
		.container{margin: auto; padding: 0; width: 960px;}
		.clear{clear: both; height: 1px; line-height: 1px; margin-bottom: -1px; overflow: hidden;}
		.Lfloat{float: left;}
		.Rfloat{float: right;}
		a:link, a:visited, a:active{text-decoration: none; color: inherit;}

		header{padding: 20px 0; border-bottom: 1px solid; margin-bottom: 50px;}
		header .container{text-align: center;}
		.header-p{font-size: 2.5em; display: inline-block; vertical-align: 8px; font-weight: bold;}

		.subject{font-size: 2em; margin-bottom: 20px; color: blue; font-style: italic;}
		.example-div{display: inline-block; padding: 10px 25px; background: #fbfaf8; font-size: 19px; border: 1px solid #ccc;
				  	 white-space: pre-line; margin-bottom: 13px; line-height: 1.7;}
		.example-div p, .openMe p{margin-bottom: 13px;}

		.token{color: #07a;}
		.keyword{color: #DD4A68;}
		.integer{color: #990055;}
		.comment{color: #b4b4b4;}
		.string{color: #669900;}

		.method-title{font-weight: bold; cursor: pointer; border-bottom: 2px solid; display: inline-block; 
					  padding-bottom: 1px; margin-bottom: 15px; color: blue; font-size: 1.5em;}
		.method-div{margin-bottom: 25px;}
		.display{display: inline-block;}
		.martop15{margin-top: 15px;}
		.string-color{color: #690;}
		.ab-list{margin-left: 28px; margin-top: 10px;}
		.ab-list li{list-style-type: upper-alpha !important;}
		.one-two-list{margin-left: 20px;}
		.one-two-list a{color: blue; text-decoration: underline;}
		.one-two-list li{list-style-type: decimal; margin-bottom: 10px;}

		@media (max-width: 980px) {
			.container{width: auto; padding: 0 15px 0 20px;}
			.header-p, .subject{font-size: 1.2em;}
			body{word-break: break-word;}
		}

	</style>
		<!--[if lt IE 9]>
		<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
	</head>
	<body>
		<header>
			<div class="container">
				<p class="header-p">Fundamentals of Javascript Notes</p>
			</div>
		</header>
		<div class="container">
				<div class="method-div">
					<p class="method-title">Javascript Basics</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>JavaScript is an interpreted, object-based scripting language.</li>
							<li>The language supports various data types, including String, Number, Boolean, Object, and Array. </li>
							<li>JavaScript is a <b>loosely typed language</b>, which means you do not declare what kind of data type each variable or object is. Meaning, you do not declare:</li>
							<div class="example-div">Integer <span class="token">var</span> int = <span class="integer">13</span></div>
							<p>but rather you just declare:</p>
							<div class="example-div"><span class="token">var</span> int = <span class="integer">13</span></div>
							<p>and the interpreter will know it is an integer.</p>
							<li>Like many other programming languages, JavaScript is organized into <b>statements</b>, blocks consisting of related sets of statements, and comments. Within a statement you can use variables, strings, numbers, and expressions. So a JavaScript program is a collection of statements. JavaScript statements combine expressions in such a way that they carry out one complete task. Every line of code in a program is called a "statement".</li>
							<li>A group of JavaScript statements surrounded by braces ({}) is called a block. Statements grouped into a block can generally be treated as a single statement. </li>
							<li>Generally, blocks are used in functions and conditionals. Unlike other programming languages, JavaScript does not consider a block to be a new scope; ONLY functions create a new scope.</li>
							<li>Javascript also has <b>expressions</b>. An expression is any valid unit of code that resolves to a value (meaning value is expected) , such as:</li>
							<div class="example-div"><span class="token">var</span> x = <span class="integer">2</span> <span class="comment">// a very simple example of an expression</span></div>
							<p>The vague difference a statement and an expression is that an expression expects a value whereas a statement performs an action such as a "for loop". Wherever JavaScript expects a statement, you can also write an expression. Such a statement is called an expression statement. The reverse does not hold: you cannot write a statement where JavaScript expects an expression. For example, an if statement cannot become the argument of a function.</p>
							<li>Javascript has the ability to run <b>Asynchronous programming</b>. In this type of programming, the engine runs in an event loop. On encountering a blocking operation, a request gets fired and the code keeps running without blocking for the result. When its execution completes, and the response is ready, it fires an interrupt, which causes an event handler to be run, where the control flow continues. In this way, a single program thread can handle many concurrent operations in an asynchronous programming. The user interface is asynchronous by nature and spends most of the time, waiting for user input to interrupt the event loop and trigger event handlers. This concept is important in JavaScript because it's suitable for user interface code and beneficial for maintaining the performance on the server.</li>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Variables</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>Javascript <b>variables</b> are data types that store data values. All variables in the JavaScript are object data types.</li>
							<li>JavaScript is a case-sensitive language. This means that a variable name such as myCounter is different from the variable name MYCounter.</li>
							<li>Variable typing is used to assign a number to a variable and the same variable can be assigned to a string.</li>
							<div class="example-div">i = 10;
 							i = <span class="string">"string";</span></div>
							<li>The rules for creating legal variable names are as follows: 
								<ul class="ab-list">
									<li>The first character must be an ASCII (American Standard Code for Information Interchange) letter (either uppercase or lowercase), or an underscore ( _ ) character. Note that a number cannot be used as the first character.</li>
									<li>Following characters must be letters, numbers, or underscores ( _ ).</li>
									<li>The variable name must not be a reserved word (break, default, function, return, var, case delete, if, switch, void, catch, do, in, this, while, const, else, instanceOf, throw, with, continue, finally, let, try, debugger, for, new, typeof)</li>
								</ul>
							</li>
							<p>Here are some examples of valid variable names:</p>
							<div class="example-div">_pagecount   
							Part9   
							Number_Items</div>
							<p>Here are some examples of invalid variable names:</p>
							<div class="example-div"><span class="comment">// Cannot begin with a number.</span>   
								99Balloons     
								<span class="comment">// The ampersand (&amp;) character is not a valid character for variable names.   </span>
								Alpha&amp;Beta</div>
							<li><b>Coercion</b> is the process in which the JavaScript interpreter implicitly converts a data type to that of the other (since JS is a loosely typed language), then performs the operation. </li>
							<li>The rules for coercion of string, number, and Boolean values are the following:
								<ul class="ab-list">
									<li>If you add a number and a string, the number is coerced to a string.</li>
									<li>If you add a Boolean and a string, the Boolean is coerced to a string.</li>
									<li>If you add a number and a Boolean, the Boolean is coerced to a number ( "true" is worth 1               whereas "false" is equal to 0 ).</li>
								</ul>
							</li>
							<p>In the following example, a number added to a string results in a string:</p>
							<div class="example-div"><span class="token">var</span> x = <span class="integer">2000</span>;  
								<span class="token">var</span> y = "Hello";  
								<span class="comment">// The number is coerced to a string.</span>  
								x = x + y;  
								document.<span class="keyword">write</span>(x);   
								<span class="comment">// Output:
									// 2000Hello  </span></div>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Data Types</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>In JavaScript, there are three primary data types, two composite data types, and two special data types.</li>
							<li>The 3 primary (primitive, meaning they are built into the language) data types are: <b>String, Number, and Boolean</b>.</li>
							<li>The 2 composite (reference, meaning they are stored in memory like variables) data types are: <b>Object and Array.</b></li>
							<li>The special data types are: <b>Null and Undefined.</b></li>
							<li><b>String Data Type</b>: A string value is a chain of zero or more Unicode characters (letters, digits, and punctuation marks). You use the string data type to represent text in JavaScript. You include string literals in your scripts by enclosing them in single or double quotation marks.</li>
							<li><b>Number Data Type</b>: In JavaScript, there is no distinction between integer and floating-point values; a JavaScript number can be either (internally, JavaScript represents all numbers as floating-point values).</li>
							<li>Additionally, JavaScript contains numbers with special values such as <b>NaN (not a number)</b>. This is used when a mathematical operation is performed on inappropriate data, such as strings or the undefined value. Even though NaN is not a number, it is still considered a Number Object.</li>
							<li>The <b>undefined</b> value is returned when you use an object property that does not exist, or a variable that has been declared, but has never had a value assigned to it.</li>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Operators</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>JavaScript has a full range of operators, including arithmetic, logical, bitwise, assignment, as well as some miscellaneous operators.</li>
							<li><b>Computational Operators:</b> unary negation ( - ) , increment  ( + ) , decrement  ( -- ) , multiplication ( * ) , division ( / ) , modulus arithmetic ( % ) , addition ( + ) , subtraction ( - ) .</li>
							<li><b>Bitwise Operators:</b> Bitwise NOT (  ~  ) , Bitwise Left Shift ( << ) , Bitwise Right Shift ( >> ) , Unsigned Right Shift	( >>> ) , Bitwise AND ( &amp; ) ,  Bitwise XOR ( ^ ) , Bitwise OR ( | ).</li>
							<li>Assignment Operators:</b> Assignment	 ( = ) , Compound Assignment ( Operator= (such as += and &amp;= ) .</li>
							<li><b>Miscellaneous Operators:</b> delete (deletes a property from an object, or removes an element from an array), typeof (returns a string that identifies the data type of an expression), void ( prevents an expression from returning a value ), instanceof ( returns a Boolean value that indicates whether or not an object is an instance of a particular class ), new ( Creates a new object ), in ( tests for the existence of a property in an object ).</li>
							<li><b>Equality and Strict Equality:</b> The difference between == (equality) and === (strict equality) is that the equality operator will coerce (convert) values of different types before checking for equality. For example, comparing the string "1" with the number 1 will compare as true. The strict equality operator, on the other hand, will not coerce values to different types, and so the string "1" will not compare as equal to the number 1. So although == checks the value to be equal whereas === checks value and data type. </li>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Operator Precedence</p>
					<div class="openMe">
					<p>Operator precedence describes the order in which operations are performed when an expression is evaluated. Operations with a higher precedence are performed before those with a lower precedence. For example, multiplication is performed before addition. Here is the list by order of precedence that are evaluated left to right:</p>
						<ul class="one-two-list">
							<li>.  Field access, array indexing, function calls, and expression grouping.</li>
							<li>++ -- - ~ ! delete new typeof void Unary operators, return data type, object creation, undefined values.</li>
							<li>* / %  Multiplication, division, modulo division.</li>
							<li>+ - +  Addition, subtraction, string concatenation.</li>
							<li><< >> >>  Bit shifting.</li>
							<li>< <= > >= instanceof  Less than, less than or equal, greater than, greater than or equal, instanceof.</li>
							<li>== != === !== Equality, inequality, strict equality, and strict inequality.</li>
							<li>&amp; Bitwise AND.</li>
							<li>^  Bitwise XOR.</li>
							<li>|  Bitwise OR.</li>
							<li>&amp;&amp;	Logical AND.</li>
							<li>||	Logical OR.</li>
							<li>?:	Conditional.</li>
							<li>= OP=	Assignment, assignment with operation (such as += and &amp;=).</li>
							<li>,  Multiple evaluation.</li>
							<li>Parentheses are used to alter the order of evaluation determined by operator precedence. This means an expression within parentheses is fully evaluated before its value is used in the remainder of the expression. </li>
								<div class="example-div"><span class="token">var</span> result = <span class="integer">78</span> * <span class="integer">96</span> + <span class="integer">3</span>;  
								document.<span class="keyword">write</span>(result);  
								result = <span class="integer">78</span> * (<span class="integer">9</span> + <span class="integer">3</span>);  
								document.<span class="keyword">write</span>(result);  
								<span class="comment">// Output:  
								// 7491  
								// 936 </span> </div>
							
							<p>The following example shows a statement that includes a variety of operators and resolves to "true":</p>
							<div class="example-div"><span class="token">var</span> num = <span class="integer">10</span>;  
								if(<span class="integer">5</span> == num / <span class="integer">2</span> &amp;&amp; (<span class="integer">2</span> + <span class="integer">2</span> * num).toString( ) === <span class="string">"22"</span>) {  
								    document.<span class="keyword">write</span>(true);  
								}  
								   <span class="comment"> // Output:  
								    // true </span> </div>
							<p>The operators are evaluated in this order: ( ) for the grouping, *, + (within the grouping), "." for the function, ( ) for the function, /, ==, ===, and &amp;&amp;.</p>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Controlling Program Flow</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>Normally, statements in a JavaScript script are executed one after the other, in the order in which they are written. This is called <b>sequential execution</b>, and is the default direction of program flow.</li>
							<li>An alternative to sequential execution transfers the program flow to another part of your script. That is, instead of executing the next statement in the sequence, another statement is executed instead.  There are two main kinds of program structures that accomplish this. </li>
							<li>The first is the <b>selection structure</b>. You use it to specify alternate courses of program flow, creating a junction in your program (like a fork in a road). There are four selection structures available in JavaScript. 
							<ul class="ab-list">
									<li>the single-selection structure (<b>if)</b></li>
									<li>the double-selection structure (<b>if/else)</b></li>
									<li>the inline ternary operator <b>?: (aka conditional operator)</b></li>
									<li>the multiple-selection structure (<b>switch)</b></li>
								</ul>
							</li>
							<li>The second type of program control structure is the <b>repetition structure</b>. You use it to specify that an action is to be repeated while some condition remains true. When the conditions of the control statement have been met (usually after some specific number of iterations), control passes to the next statement beyond the repetition structure. There are four repetition structures available in JavaScript:
								<ul class="ab-list">
									<li>the expression is tested at the top of the loop <b>(while)</b></li>
									<li>the expression is tested at the bottom of the loop <b>(do/while)</b></li>
									<li>operate on each of an object's properties <b>(for/in)</b></li>
									<li>counter controlled repetition <b>(for)</b></li>
								</ul>
							</li>
							<li>JavaScript also supports an implicit conditional form called <b>Conditional Operator</b>. It uses a question mark after the condition to be tested (rather than the word if before the condition). It also specifies two alternatives, one to be used if the condition is met and one if it is not. A colon must separate these alternatives:</li>
							<div class="example-div"><span class="token">var</span> AMorPM = (theHour >= <span class="integer">12</span>) ? <span class="string">"PM"</span> : <span class="string">"AM"</span>;</div>
							<li>If you have several conditions to be tested together, and you know that one is more likely to pass or fail than the others, you can use a feature called <b>short circuit evaluation</b> to speed the execution of your script. When JavaScript evaluates a logical expression, it only evaluates as many sub-expressions as required to get a result. For example, if you have an AND expression such as ((x == 123) &amp;&amp; (y == 6)), JavaScript first checks if x is 123. If it is not, the entire expression cannot be true, even if y is equal to 6. Hence, the test for y is never made, and JavaScript returns the value false.</li>
							<li>Here are the different loops and a general guide of when to use each:
								<ul class="ab-list">
									<li><b>For Loops:</b> When you know how many times you want to loop. When you are iterating through the indices of an array. When you have some sort of counter. It is also the fastest performing loop according to JsPerf.   </li>
									<li><b>For-In Loops:</b> When you are iterating over the properties of an object.</li>
									<li><b>For-Each:</b> When you want to iterate over the values of an object's properties.</li>
									<li><b>While Loops:</b> When you may be unsure of the number of times to loop. When you want to loop while some condition is true.</li>
									<li><b>Do-While Loops:</b> When you want it to loop at least once before checking if the condition is true.</li>
								</ul>
							</li>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Displaying Text in a Webpage</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>The recommended way to display text is to create an element and write to its <b>textContent</b> property.</li> 
							<div class="example-div"><span class="token">var</span> div = document.<span class="keyword">getElementById</span>(<span class="string">"textDiv"</span>);  
							    div.textContent = <span class="string">"my text"</span>;  
							    <span class="token">var</span> text = div.textContent;</div>
							<li>You can also create an element and write to its <b>innerHTML</b> or <b>innerText</b> properties. Setting these properties affects only the text in the element itself, not in its children. However, these properties also have some disadvantages:
								<ul class="ab-list">
									<li>The innerText property doesn't work in all browsers, so you might want to avoid it for reasons of compatibility.</li>
									<li>The innerText property is affected by CSS styles, and doesn't appear if the element is hidden.</li>
									<li>The innerHTML property gets and sets both nested nodes and text. If it isn't secured, it could be used for script-injection attacks. In addition, setting it to text without HTML tags removes all previously set nodes.</li>
									<li>You can use the document.write method without having to create an element. However, using this method causes the entire web page to be cleared, which might not be what you want.</li>
								</ul>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">HTML DOM Events</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>JavaScript's interaction with HTML is handled through events that occur when the user or the browser manipulates a page. </li> 
							<li>Events are a part of the <b>Document Object Model</b> (DOM) Level 3 and every HTML element contains a set of events which can trigger JavaScript Code.</li>
							<li>Each available event has an <b>event handler</b>, which is a block of code (usually a user-defined JavaScript function) that will be run when the event fires. When such a block of code is defined to be run in response to an event firing, we say we are registering an event handler. Note that event handlers are sometimes called <b>event listeners</b> &ndash; they are pretty much interchangeable for our purposes, although strictly speaking they work together. The listener listens out for the event happening, and the handler is the code that is run in response to it happening.</li>
							<li>There are a number of different ways in which you can add event listener code to web pages so that it will be run when the associated event fires:</li>
							<div class="example-div"><span class="comment">// Event handler properties</span>
							<span class="token">var</span> btn = document.<span class="keyword">querySelector</span>(<span class="string">'button'</span>);
							btn.onclick = <span class="token">function</span>( ) {
							  <span class="token">var</span> rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
							  document.body.style.backgroundColor = rndCol;
							}</div>
							<p>You could also set the handler property to be equal to a named function name. The following would work just the same:</p>
							<div class="example-div"><span class="token">var</span> btn = document.<span class="keyword">querySelector</span>(<span class="string">'button'</span>);
								<span class="token">function</span> <span class="keyword">bgChange</span>( ) {
								  <span class="token">var</span> rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
								  document.body.style.backgroundColor = rndCol;
								}
								btn.onclick = bgChange;</div>
							<p>Inline event handlers &ndash; (don't use these) :</p>
							<div class="example-div"><span class="token">function</span> <span class="keyword">bgChange</span>( ) {
									  <span class="token">var</span> rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
									  document.body.style.backgroundColor = rndCol;
									}</div>
							<p>For a start, it is not a good idea to mix up your HTML and your JavaScript, as it becomes hard to parse &ndash; keeping your JavaScript all in one place is better; if it is in a separate file you can apply it to multiple HTML documents.  One button is OK, but what if you had 100 buttons? You'd have to add 100 attributes to the file; it would very quickly turn into a maintenance nightmare. <br>With JavaScript, you could easily add an event handler function to all the buttons on the page no matter how many there were, using something like this:</p>
							<div class="example-div"><span class="token">var</span> buttons = document.<span class="keyword">querySelectorAll</span>(<span class="string">'button'</span>);
							for (<span class="token">var</span> i = 0; i < buttons.length; i++) {
							  buttons[i].onclick = bgChange;
							}</div>
							<p>The newest type of event mechanism is defined in the Document Object Model (DOM) Level 2 Events Specification, which provides browsers with a new function &ndash; <b>addEventListener( )</b>. This functions in a similar way to the event handler properties, but the syntax is obviously different. We could rewrite our random color example to look like this:</p>
							<div class="example-div"><span class="token">var</span> btn = document.<span class="keyword">querySelector</span>(<span class="string">'button'</span>);
							<span class="token">function </span><span class="keyword">bgChange</span>( ) {
							  <span class="token">var</span> rndCol = 'rgb(' + <span class="keyword">random</span>(255) + ',' + <span class="keyword">random</span>(255) + ',' + <span class="keyword">random</span>(255) + ')';
							  document.body.style.backgroundColor = rndCol;
							}   
							btn.addEventListener('click', bgChange);</div>
							<p>So inside the addEventListener( ) function, we specify two parameters &ndash; the name of the event we want to register this handler for, and the code that comprises the handler function we want to run in response to it. The third parameter is optional; it is a Boolean value that specifies whether the event should be executed in the capturing or in the bubbling phase. Possible values: <b>true</b> - The event handler is executed in the capturing phase.<br>
							<b>false</b>- Default. The event handler is executed in the bubbling phase<br>Note that it is perfectly appropriate to put all the code inside the addEventListener( ) function, in an anonymous function, like this:</p>
							<div class="example-div">btn.<span class="keyword">addEventListener</span>('click', <span class="token">function</span>( ) {
							  <span class="token">var</span> rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
							  document.body.style.backgroundColor = rndCol;
							});</div>
							<li>Sometimes inside an event handler function you might see a parameter specified with a name such as event, evt, or simply e. This is called the <b>event object</b>, and it is automatically passed to event handlers to provide extra features and information. For example, let's rewrite our random color example again slightly:</li>
							<div class="example-div"><span class="token">function</span> <span class="keyword">bgChange</span>(e) {
								  <span class="token">var</span> rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
								  e.target.style.backgroundColor = rndCol;
								  console.log(e);
								}  
								btn.addEventListener('click', bgChange);</div>
							<p>Here you can see that we are including an event object, e, in the function, and in the function setting a background color style on <b>e.target</b> &ndash; which is the button itself. The target property of the event object is always a reference to the element that the event has just occurred upon. So in this example we are setting a random background color on the button, not the page. e.target is incredibly useful when you want to set the same event handler on multiple elements, and do something to all of them when an event occurs on them. </p>
							<li><b>Event delegation</b> is a mechanism of responding to ui-events (event handlers) via a single common parent rather than each child. So instead of calling an event on every single child element and having your function attach an event listener to each separate child, you can just delegate (assign) the event to the parent element that can target each child element individually and thus attach only one event listener.</li>
							<div class="example-div">ul id="todo-app"
								  li class="item" Walk the dog/li
								  li class="item" Pay bills/li
								  li class="item" Make dinner/li
								  li class="item" Code for one hour/li
								/ul

								document.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="token">function</span>( ) {
								  <span class="token">let</span> app = document.getElementById(<span class="string">'todo-app'</span>);
								  <span class="token">let</span> items = app.getElementsByClassName(<span class="string">'item'</span>);
								  <span class="comment">// attach event listener to each item</span>
								  for (<span class="token">let</span> item of items) {
								    item.addEventListener(<span class="string">'click'</span>, <span class="token">function</span>( ) {
								      alert(<span class="string">'you clicked on item: '</span> + item.innerHTML);
								    });
								  }
								});
							</div>
							<li><b>Event bubbling and capturing</b> are two mechanisms that describe what happens when two handlers of the same event type are activated on one element. The browsers then handle the conflicting situations in 1 of 2 different ways:
								<ul class="ab-list">
									<li><b>Capturing:</b> The browser checks to see if the element's outer-most ancestor ("html") has an onclick event handler registered on it in the capturing phase, and runs it if so. Then it moves on to the next element inside html tag and does the same thing, then the next one, and so on until it reaches the element that was actually clicked on.</li>
									<li><b>Bubbling:</b> The browser checks to see if the element that was actually clicked on has an onclick event handler registered on it in the bubbling phase, and runs it if so. Then it moves on to the next immediate ancestor element and does the same thing, then the next one, and so on until it reaches the html tag element.</li>
								</ul>
								<p>In modern browsers, by default, all event handlers are registered in the bubbling phase.</p>
							</li>
							<li>Bubbling and capturing are also ways to properly administer event delegation.</li>
							<li>The standard event object has a function available on it called <b>stopPropagation( )</b>, which when invoked on a handler's event object makes it so that handler is run, but the event doesn't bubble any further up the chain, so no more handlers will be run.</li>
							<li>There are many DOM Events and you can find a full list online. The most used are the Mouse Events which include onclick, onmousedown, onmouseover, etc. and Keyboard Events which have onkeydown, onkeypress, and onkeyup.</li>
							<li>The DOM elements in Javascript are accessed by the <b>getElementsByTagName( ) Method</b>. There are several ways to use this method:
								<ul class="ab-list">
									<li>Finding HTML elements by id <b>document.getElementById( )</b></li>
									<li>Finding HTML elements by tag name (the element itself such as a p tag) <b>document.getElementsByTagName( )</b></li>
									<li>Finding HTML elements by class name <b>document.getElementsByClassName( )</b></li>
									<li>Finding HTML elements by CSS selectors (for this you would use the css selectors in the parenthesis such as "." or "#") <b>document.querySelector( )</b> or <b>document.querySelectorAll( )</b> to grab all elements with that selector.</li>
								</ul>
							</li>
							<li>Another very important problem when attaching event listeners to DOM elements is that your event may fire thousands of times within the span of 3 seconds and this can cause some serious performance issues. Classic examples include window resizing and scrolling events that can triggers event listeners multiple times a second. <br>There are two famous ways to tackle this issue: <b>debouncing</b> and <b>throttling</b></li>
							<li><b>Debouncing</b> is enforces that a function not be called again until a certain amount of time has passed without it being called. As in "execute this function only if 100 milliseconds have passed without it being called."</li>
							<div class="example-div"><span class="comment">// debounce function that will wrap our event</span>
								function <span class="keyword">debounce</span>(fn, delay) {
								  <span class="comment">// maintain a timer</span>
								  <span class="token">let</span> timer = null;
								  <span class="comment">// closure function that has access to timer</span>
								  return <span class="token">function</span>( ) {
								   <span class="comment"> // get the scope and parameters of the function via 'this' and 'arguments'</span>
								    <span class="token">let</span> context = this;
								    <span class="token">let</span> args = arguments;
								    <span class="comment">// if event is called, clear the timer and start over</span>
								    <span class="keyword">clearTimeout</span>(timer);
								    timer = <span class="keyword">setTimeout</span>(<span class="token">function</span>( ) {
								      fn.apply(context, args);
								    }, delay);
								  }
								}
								
								<span class="comment">// function to be called when user scrolls</span>
								function <span class="keyword">foo</span>( ) {
								  console.log(<span class="string">'You are scrolling!'</span>);
								}

								<span class="comment">// wrap our function in a debounce to fire once 2 seconds have gone by</span>
								<span class="token">let</span> elem = document.getElementById('container');
								elem.addEventListener('scroll', debounce(foo, 2000));
							</div>
							<li><b>Throttling</b> enforces a maximum number of times a function can be called over time. As in "execute this function at most once every 100 milliseconds."</li>
							<div class="example-div"><span class="token">var</span> throttle = <span class="token">function</span>(func, limit) {
									  <span class="token">var</span> inThrottle,
									    lastFunc,
									    lastRan;
									  return <span class="token">function</span>( ) {
									    <span class="token">var</span> context = this,
									      args = arguments;
									    if (!inThrottle) {
									      func.apply(context, args);
									      lastRan = Date.now( )
									      inThrottle = true;
									    } else {
									      <span class="keyword">clearTimeout</span>(lastFunc)
									      lastFunc = setTimeout(function( ) {
									        if ((Date.now( ) - lastRan) >= limit) {
									          func.apply(context, args)
									          lastRan = Date.now( )
									        }
									      }, limit - (Date.now( ) - lastRan))
									    }
									  };
									};

									throttleBtn.addEventListener(<span class="string">'click'</span>, throttle(<span class="token">function</span>( ) {
								  return console.log(<span class="string">Hey! It is'</span>, new Date( ).toUTCString( ));
								}, 1000));
							</div>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Recursion</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>Loosely defined, <b>recursion</b> is the process of taking a big problem and sub-dividing it into multiple, smaller instances of the same problem. Put into practice, that generally means writing a function that calls itself. Probably the most classic example of this concept is the <b>factorial function</b>.</li> 
							<div class="example-div"><span class="token">function</span> <span class="keyword">factorial</span>( n ) {
								  <span class="token">if</span> ( n === 1 ) {
								    return 1;
								  }
								  return n * factorial( n - 1 );
								}</div>
							<li>Another good example of recursion is the classic string reversal problem:</li>
								<div class="example-div"><span class="token">function</span> <span class="keyword">reverse</span>( str ) {
								  <span class="token">if</span> ( str.length <= 1 ) {
								    return str;
								  }
								  return <span class="keyword">reverse</span>( str.substr( 1 ) ) + str[ 0 ];
								}</div>
							<p>NOTICE that these examples have a <b>Leave Event</b>; a control statement that allows the function to exit the recursive loop. WIthout that you will get stuck in an infinite loop:</p>
							<div class="example-div"><span class="token">function</span> <span class="keyword">demo</span>( ) {
							    <span class="keyword">demo</span>( );
							}
							    <span class="keyword">demo</span>( );</div>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Calculating Dates and Times</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>You can use the <b>Date object</b> to perform common calendar and clock tasks, such as comparing dates and calculating elapsed time. When you create an instance of the Date object without specifying a date, it returns a value that represents the current date and time, including year, month, day, hour, minute, second, and millisecond. You can then read or modify this date and time.</li> 
							<li>The following example shows how to instantiate a date without using any parameters and display it in the format mm-dd-yy:</li>
							<div class="example-div"><span class="token">var</span> dt = <span class="token">new</span> <span class="keyword">Date</span>( );  
							<span class="comment">// Display the month, day, and year. getMonth( ) returns a 0-based number. </span> 
							<span class="token">var</span> month = dt.<span class="keyword">getMonth</span>( )+1;  
							<span class="token">var</span> day = dt.<span class="keyword">getDate</span>( );  
							<span class="token">var</span> year = dt.<span class="keyword">getFullYear</span>( );  
							document.<span class="keyword">write</span>(month + '-' + day + '-' + year);  
							<span class="comment">// Output: current month, day, year </span> </div>
							<li>You can also set a specific date by passing a date string to the constructor:</li>
							<div class="example-div"><span class="token">var</span> myDate = <span class="token">new</span> Date(<span class="string">"1/1/1990"</span>)  
							myDate.<span class="keyword">setMonth</span>(myDate.<span class="keyword">getMonth</span>( ) + 1);  
							myDate.<span class="keyword">setDate</span> (myDate.<span class="keyword">getDate</span>( ) - 1);  
							document.<span class="keyword">write</span>(myDate);  
							<span class="comment">// Output: Wed Jan 31 00:00:00 PST 1990 </span> </div>
							<li>The time zone displayed in the date string corresponds to the time zone set on the local machine. JavaScript is flexible about the format of the string you use as the parameter. For example, you can input "8-24-2009", "August 24, 2009", or "24 Aug 2009".</li>
							<li>You can use the <b>getX</b> and <b>setX</b> methods of the Date object to set specific dates and times. The following example shows how you can set a date to the previous day. Note that if necessary the month and year values are also changed:</li>
							<div class="example-div"><span class="token">var</span> myDate = <span class="keyword">new Date</span>(<span class="string">"1/1/1990"</span>);  
							<span class="token">var</span> dayOfMonth = myDate.<span class="keyword">getDate</span>( );  
							myDate.<span class="keyword">setDate</span>(dayOfMonth - 1);  
							document.<span class="keyword">write</span>(myDate);  
							<span class="comment">// Output: Sun Dec 31 00:00:00 PST 1989</span>  </div>
							<li>The <b>getDay method</b> gets the day of the week as a number between 0 (Sunday) and 6 (Saturday). (This is not the same as the <b>getDate method</b>, which gets the day of the month as a number between 1 and 31).</li>
							All objects in JavaScript support expando properties and methods, which can be added and removed at run time. These properties and methods can have any name and can be identified by numbers. If the name of the property or method is a simple identifier, it can be written after the object name with a period, such as myObj.name, myObj.age, and myObj.getAge in the following code:
							<li>When you compare dates in JavaScript, you should keep in mind that the == operator returns true only if the dates on both sides of the operator refer to the same object. Therefore, if you have two separate Date objects set to the same date, date1 == date2 returns false. In addition, a Date object set with only the date and not the time is initialized to midnight of that date. So if you compare one Date set without a specified time to Date.now, for example, you should be aware that the first Date is set to midnight and Date.now is not.</li>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Copying, Passing, and Comparing Data</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>In JavaScript, how data is handled depends on its data type. Numbers and Boolean values (true and false) are copied, passed, and compared by value. When you copy or pass by value, you allocate a space in computer memory and copy the <b>value</b> of the original into it. If you then change the original, the copy is not affected (and vice versa), because the two are separate entities.</li>
							<li>Objects, arrays, and functions are copied, passed, and compared by <b>reference</b>. When you copy or pass by reference, you essentially create a pointer to the original item, and use the pointer as if it were a copy. If you then change the original, you change both the original and the copy (and vice versa). There is really only one entity; the "copy" is not actually a copy, it's just another reference to the data.</li>
							<li>When comparing by reference, the two variables must refer to exactly the same entity for the comparison to succeed. For example, two distinct Array objects will always compare as unequal, even if they contain the same elements. One of the variables must be a reference to the other one for the comparison to succeed. </li>
							<li><b>Strings</b> are copied and passed by reference, but are compared by value. Note that if you have two String objects (created with new String("something")), they are compared by reference, but if one or both of the values is a string value, they are compared by value.</li>
							<li>Copying and passing strings by reference saves memory; but because you cannot change strings once they are created, it becomes possible to compare them by value. This lets you test whether two strings have the same content even if one was generated entirely separately from the other.</li>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Functions</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>JavaScript <b>functions</b> perform actions; they can also return values. Sometimes these are the results of calculations or comparisons. Functions are also called "global methods". Functions combine several operations under one name. This lets you streamline your code. You can write out a set of statements, name it, and then execute the entire set by calling it and passing to it any information it needs. </li>
							<li>JavaScript supports two kinds of functions: those that are built into the language, and those you create yourself. </li>
							<li><b>Anonymous</b> functions are functions that are dynamically declared at runtime. They're called anonymous functions because they don't have a name like normal functions.</li>
							<li>The JavaScript language includes several built-in functions. Some let you handle expressions and special characters, while others convert strings to numeric values. The most famous you would know are the getDate Method that allows you to get the date, time, hour, minute, seconds, etc.</li>
							<li>You will often hear that <b>"Functions are first class Objects"</b>, that is, functions are of the type Object and they can be used in a first-class manner like any other object (String, Array, Number, etc.) since they are in fact objects themselves. They can be stored in variables, passed as arguments to functions, created within functions, have their own methods, and returned from functions.</li>
							<li><b>Nested functions</b>: The functions, which are defined inside other functions, are called Nested functions. They are called 'everytime' the main function is invoked.</li>
							<li>A function that takes other functions as arguments or returns functions as its result is called a <b>higher-order function</b>, and the function that is passed as an argument is called a <b>callback function</b>. It's named "callback" because at some point in time it is "called back" by the higher-order function.</li>
							<li><b>Callbacks</b> are heavily used in JavaScript libraries to provide generalization and re-usability. They allow the library methods to be easily customized and/or extended. Also, the code is easier to maintain, and much more concise and readable. Every time you need to transform your unnecessary repeated code pattern into more abstract/generic function, callbacks come to the rescue.</li>
							<li>A good example of a callback function is when we attach an event listener to an element on a page. By doing that we're actually providing a pointer to a callback function that will be called when the event occurs:</li>
							<div class="example-div"><span class="token">function</span> <span class="keyword">showMessage</span>( ){
								  alert(<span class="string">'Woohoo!'</span>);
								}
								<span class="token">var</span> el = document.<span class="keyword">getElementById</span>(<span class="string">"btn"</span>);
								el.addEventListener(<span class="string">"click"</span>, <span class="keyword">showMessage</span>);
							</div>
							<li>An <b>Immediately-invoked function expression</b>, or <b>IIFE</b> (pronounced "iffy"), is a function expression (named or anonymous) that is executed right away after its creation.</li>
							<li>There are two slightly different syntax variations of this pattern:</li>
							<div class="example-div"><span class="comment">// variant 1</span>
								(<span class="token">function</span> ( ) {
								  alert(<span class="string">'Woohoo!'</span>);
								})( );

								<span class="comment">// variant 2</span>
								(<span class="token">function</span> ( ) {
								  alert(<span class="string">'Woohoo!'</span>);
								}( ));
							</div>
							<li>To turn a regular function into an IIFE you need to perform two steps:
								<ul class="ab-list">
									<li>You need to wrap the whole function in parentheses. As the name suggests, an IIFE must be a function expression, not a function definition. So, the purpose of the enclosing parentheses is to transform a function definition into an expression. This is because, in JavaScript, everything in parentheses is treated as an expression.</li>
									<li>You need to add a pair of parentheses at the very end (variant 1), or right after the closing curly brace (variant 2), which causes the function to be executed immediately.</li>
								</ul>
							</li>
							<li>An IIFE is often used to create scope to <b>encapsulate modules</b>. Within the module there is a private scope that is self-contained and safe from unwanted or accidental modification. This technique, called the <b>module pattern</b>, is a powerful example of using closures to manage scope, and it's heavily used in many of the modern JavaScript libraries (jQuery and Underscore, for example).</li>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Objects and Arrays </p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>JavaScript objects are collections of <b>properties</b> and <b>methods</b>. A property is a value or set of values (in the form of an array or object) that is a member of an object. A method is an object property that references a function.</li>
							<div class="example-div"><span class="comment">// property example where the "user" object has the two properties, "name" and "age" with their respective values</span>
								<span class="token">var</span> user = {    
								  <span class="keyword">name</span>: <span class="string">"John"</span>,  
								  <span class="keyword">age</span>: 30 
								};
								
								<span class="comment">// method example</span>
								<span class="token">var</span> obj = {
								  <span class="keyword">helloWorld</span> : <span class="token">function</span>( ) {
								    return <span class="string">"hello world, "</span> + this.name;
								  },
								  name: <span class="string">'John Carter'</span>
								}
								obj.<span class="keyword">helloWorld</span>( ); <span class="comment">// "hello world John Carter"</span>
							</div>
								<li>There are also <b>built-in methods</b> of built-in objects in Javascript like the methods you will find for the String, Number, and Array objects that can be called automatically on the respective object type:</li>
								<div class="example-div"><span class="comment">// String Object Method</span>
								<span class="token">var</span> txt = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;
								<span class="token">var</span> str = txt.<span class="keyword">length</span>;
								
								<span class="comment">// Number Object Method</span>
								<span class="token">var</span> x = 123;
								x.<span class="keyword">toString</span>( ); <span class="comment"> // returns 123 from variable x</span>

								<span class="comment">// Array Object Method</span>
								<span class="token">var</span> arr = new Array(<span class="string">"4", "11", "2", "10", "3", "1"</span>);  
								arr.<span class="keyword">splice</span>(2, 2, <span class="string">"21", "31"</span>);  
								</div>
								<li>JavaScript supports four kinds of objects:  
								<ul class="ab-list">
									<li><b>Intrinsic (or "built-in") objects</b>, such as Array and String</li>
									<li>Objects you create</li>
									<li><b>Host objects</b>, such as 'window' and 'document'</li>
									<li><b>ActiveX objects</b> (An object that provides an interface to an Automation object)</li>
								</ul>
							</li>
							<li>All objects in JavaScript support <b>expando properties and methods</b>, which can be added and removed at run time. These properties and methods can have any name and can be identified by numbers. If the name of the property or method is a simple identifier, it can be written after the object name with a period, such as myObj.name, myObj.age, and myObj.getAge in the following code:</li>
							<div class="example-div"><span class="token">var</span> myObj = <span class="token">new</span> Object( );  
							myObj.name = <span class="string">"Fred"</span>;  
							myObj.age = 42;  
							myObj.getAge =   
							    <span class="token">function</span> ( ) {  
							        return this.age;  
							    };  
							document.<span class="keyword">write</span>(myObj.name);  
							document.<span class="keyword">write</span>(<span class="string">"<br/>"</span>);  
							document.<span class="keyword">write</span>(myObj.age);  
							document.<span class="keyword">write</span>("<br/>");  
							document.<span class="keyword">write</span>(myObj.getAge( ));  
							<span class="comment">// Output:  
							// Fred  
							// 42  
							// 42  </span></div>
							<p>If the name of the property or method is not a simple identifier or is unknown at the time you write the script, you can use an expression inside square brackets to index the property. The names of all expando properties in JavaScript are converted to strings before being added to the object.</p>
							<div class="example-div"><span class="token">var</span> myObj = <span class="token">new</span> Object( );  
							<span class="comment">// Add two expando properties that cannot be written in the  
							// object.property syntax.  
							// The first contains invalid characters (spaces), so must be  
							// written inside square brackets. </span> 
							myObj["not a valid identifier"] = "This is the property value";  
							<span class="comment">// The second expando name is a number, so it also must  
							// be placed inside square brackets </span> 
							myObj[100] = <span class="string">"100"</span>;  </div>
							<li>In JavaScript, objects and arrays are handled almost identically, because arrays are merely a special kind of object. Both objects and arrays can have properties and methods.</li>
							<li>Arrays have a length property but objects do not. When you assign a value to an element of an array whose index is greater than its length (for example, myArray[100] = "hello"), the length property is automatically increased to the new length. Similarly, if you make the length property smaller, any element whose index is outside the length of the array is deleted.</li>
							<li>JavaScript does not directly support <b>multi-dimensional arrays</b>, but you can get the behavior of multi-dimensional arrays by storing arrays within the elements of another array.</li>
							<li>In JavaScript, objects and arrays are almost identical to each other. The two main differences are that non-array objects do not have an automatic length property, and arrays do not have the properties and methods of an object.</li>	
							<li>There are two ways to accessing an object's properties:</li>
							<p>1. <b>dot notation</b> (aka dot operator)</p>
							<div class="example-div">myObject.aProperty</div>
							<p>2. <b>bracket notation</b> (aka index operator)</p>
							<div class="example-div">myObject[<span class="string">"aProperty"</span>] // Same as above.</div>
							<p><b>Notice:</b> the important difference between the two ways of accessing object properties is that the bracket notation allows you to access properties by name stored in a variable:</p>
							<div class="example-div">var obj = { <span class="string">"abc"</span> : <span class="string">"hello"</span> };
								<span class="token">var</span> x = <span class="string">"abc"</span>;
								<span class="token">var</span> y = obj[x];
								console.log(y); <span class="comment">//output - hello</span></div>
							<p>where the dot notation cannot but is easier and cleaner to read.</p>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Intrinsic Objects</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>JavaScript provides <b>intrinsic (or "built-in") objects</b>. They are the <b>Array, Boolean, Date, Error, Function, Global</b> (object whose purpose is to collect global functions and constants into one object), <b>JSON, Math, Number, Object, RegExp, and String objects</b>. The intrinsic objects have associated methods, functions, properties, and constants.</li>
							<li>The subscripts of an array can be thought of as properties of an object, and are referred to by their numeric index.</li>
							<li>When you create an array using the <b>Array</b> keyword, JavaScript includes a length property, which records the number of entries. If you do not specify a number, the length is set to 0, and the array has no entries. If you specify a number, the length is set to that number. If you specify more than one parameter, the parameters are used as entries in the array. JavaScript automatically changes the value of length when you add elements to an array that you created with the Array keyword. Array indices in JavaScript always start at 0, not 1, so the length property is always one greater than the largest index in the array.</li>
							<li>In JavaScript, you can treat strings (and numbers) as if they were objects. The string Object has certain built-in methods, which you can use with your strings.</li>
							<li>The <b>Math object</b> has a number of predefined constants and functions. The constants are specific numbers. One of these specific numbers is the value of pi (approximately 3.14159...). This is the <b>Math.PI</b> constant, shown in the following example.</li>
							<div class="example-div"><span class="token">var</span> radius = 5;  
								<span class="token">var</span> circleArea = Math.PI * radius * radius; </div>
							<li>One of the built-in functions of the Math object is the exponentiation method, or Math.pow, which raises a number to a specified power. The following example uses both pi and exponentiation to calculate the volume of a sphere:</li>
							<div class="example-div"><span class="token">var</span> volume = (4/3)*(Math.PI*Math.pow(radius,3));</div>
							<li>The Date object can be used to represent arbitrary dates and times, to get the current system date, and to calculate differences between dates. It has several properties and methods, all predefined. In general, the Date object provides the day of the week; the month, day, and year; and the time in hours, minutes, and seconds. This information is based on the number of milliseconds since January 1, 1970, 00:00:00.000 GMT, which is Greenwich Mean Time (the preferred term is UTC, or "Universal Coordinated Time," which refers to signals issued by the World Time Standard). JavaScript can handle dates that are in the approximate range 250,000 B.C. to 255,000 A.D.</li>
							<li>To create a new Date object, use the new operator, as shown in the following example:</li>
							<div class="example-div"><span class="token">var</span> toDay = <span class="token">new</span> Date( );    
								<span class="token">var</span> thisYear = toDay.getFullYear( );  
								<span class="token">var</span> thisMonth = theMonths[toDay.getMonth( )];  
								<span class="token">var</span> thisDay = thisMonth  + " " + toDay.getDate( ) + ", " + thisYear;  </div>
							<li>In addition to the special numeric constants (PI, for example) that are available in the Math object, several other constants are available in JavaScript through the <b>Number object:</b> 
								<ul class="ab-list">
									<li>Number.MAX_VALUE - Largest possible number, about 1.79E+308; can be positive or negative. (Value varies slightly from system to system.)</li>
									<li>Number.MIN_VALUE - Smallest possible number, about 5.00E-324; can be positive or negative. (Value varies slightly from system to system.)</li>
									<li>Number.NaN - Special non-numeric value, "not a number."</li>
									<li>Number.POSITIVE_INFINITY - Any positive value larger than the largest positive number (Number.MAX_VALUE) is automatically converted to this value; represented as infinity.</li>
									<li>Number.NEGATIVE_INFINITY - Any value more negative than the largest negative number (-Number.MAX_VALUE) is automatically converted to this value; represented as -infinity.</li>
								</ul>
							</li>
							<li>The <b>JSON Object</b> is a lightweight data-interchange format based on a subset of the object literal notation of the JavaScript language.</li>
							<li>The JSON object provides two functions to convert to and from JSON text format. The <b>JSON.stringify function</b> serializes objects and arrays into JSON text. The <b>JSON.parse function</b> de-serializes JSON text to produce in-memory objects.</li>	
							<div class="example-div">// strigify function
								<span class="token">var</span> obj = { <span class="string">"name":"John", "age":30, "city":"New York"</span>};
								<span class="token">var</span> myJSON = JSON.<span class="keyword">stringify</span>(obj);
								document.<span class="keyword">getElementById</span>(<span class="string">"demo"</span>).innerHTML = myJSON;
								<span class="comment">// Output:
								//{"name":"John","age":30,"city":"New York"}
								// parse function</span>
								<span class="token">var</span> jsontext = <span class="string">'{"firstname":"Jesper","surname":"Aaberg","phone":["555-0100","555-0120"]}'</span>;  
								<span class="token">var</span> contact = JSON.parse(jsontext);  
								document.<span class="keyword">write</span>(contact.surname + ", " + contact.firstname);  
								document.<span class="keyword">write</span>(contact.phone[1]);  
								<span class="comment">// Output:  
								// Aaberg, Jesper  
								// 555-0100</span>  </div>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Creating Objects</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>There are a number of ways you can create your own objects in JavaScript. You can directly instantiate an <b>Object Object</b> ( = new Object( ); ) and then add your own properties and methods. Or you can use object literal notation to define your object. You can also use a constructor function to define an object.</li>
							<li>The following code shows how to instantiate an object and add some properties. In this case only the pasta object has the grain, width, and shape properties.</li>
							<div class="example-div"><span class="token">const</span> pasta = <span class="token">new</span> Object( );  
							pasta.grain = <span class="string">"wheat"</span>;  
							pasta.width = 0.5;  
							pasta.shape = <span class="string">"round"</span>;  
							pasta.getShape = <span class="token">function</span>( ) {   
							    return this.shape;   
							};  
							document.<span class="keyword">write</span>(pasta.grain);  
							document.<span class="keyword">write</span>(<span class="string">"<br/>"</span>);  
							document.<span class="keyword">write</span>(pasta.getShape( ));  
							<span class="comment">// Output:  
							// wheat  
							// round  </span></div>
							<li>You can also use object literal notation when you want to create only one instance of an object. The following code shows how to instantiate an object by using object literal notation.</li>
							<div class="example-div"><span class="token">const</span> pasta = {  
							    grain: <span class="string">"wheat"</span>,  
							    width: 0.5,  
							    shape: <span class="string">"round"</span>  
							};  </div>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Using Constructors to Define Types</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>A <b>constructor</b> is a function that instantiates a particular type of Object. You invoke a constructor with the new keyword. Here are a few examples of constructors with built-in JavaScript objects and custom objects.</li>
							<div class="example-div">// Creates a generic object.  
								<span class="token">var</span> myObject = <span class="token">new</span> Object( );  
								<span class="comment">// Creates a Date object. </span> 
								<span class="token">var</span> myBirthday = <span class="token">new</span> Date(1961, 5, 10);  
								<span class="comment">// Creates a user defined object.</span>
								<span class="token">var</span> myCar = <span class="token">new</span> Car( );</div>
							<p>The constructor function contains the <b>this</b> keyword, which is a reference to a newly created empty object. It initializes the new object by creating properties and giving them initial values. The constructor returns a reference to the object it constructed.</p>
							<li>You can create objects using the new operator in conjunction with predefined constructor functions such as Object( ), Date( ), and Function( ). You can also create custom constructor functions that define a set of properties and methods. Here is an example of a custom constructor.</li>
							<div class="example-div"><span class="token">function</span> Circle (xPoint, yPoint, radius) {  
							    this.x = xPoint;  <span class="comment">// The x component of the center of the circle. </span> 
							    this.y = yPoint; <span class="comment"> // The y component of the center of the circle. </span>
							    this.r = radius; <span class="comment"> // The radius of the circle. </span>
							}  </div>
							<p>When you invoke the <b>Circle constructor</b>, you supply values for the circle's center point and the radius. You end up with a Circle object that contains three properties. Here is how you would instantiate a Circle object.</p>
							<div class="example-div"><span class="token">var</span> aCircle = <span class="token">new</span> Circle(5, 11, 99);</div>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Prototypes and Prototype Inheritance</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>In JavaScript, a <b>prototype</b> is a property of functions and of objects that are created by constructor functions. The prototype of a function or an object is itself an object. Objects created using an object literal, or with new Object( ), inherit from a prototype called <b>Object.prototype</b>.</li>
							<li>In the example below, the prototype of the Vehicle function is the prototype of the Vehicle2 object that is instantiated with the Vehicle constructor.</li>
							<div class="example-div"><span class="token">function</span> <span class="keyword">Vehicle</span>(wheels, engine) {  
								    this.wheels = wheels;  
								    this.engine = engine;  
								}  
								<span class="token">var</span> Vehicle2 = new Vehicle("soft-wheels", "V6 engine")    </div>
							<li>You can use the prototype property to add properties and methods to objects, even the ones that have already been created: </li>
							<div class="example-div"><span class="token">var</span> testVehicle = <span class="token">new</span> Vehicle(2, false);  
								Vehicle.prototype.color = <span class="string">"red"</span>;  
								<span class="token">var</span> testColor = testVehicle.color;  </div>
							<li>The prototype Object can be used to derive one object from another. For example, you can use the <b>Object.create</b> function to derive a new object Bicycle using the prototype of the Vehicle object we defined earlier (plus any new properties you need).</li>
							<div class="example-div"><span class="token">var</span> bicycle = Object.<span class="keyword">create</span>(Object.<span class="keyword">getPrototypeOf</span>(Vehicle), {  
							    <span class="string">"pedals"</span> :{value: true}  
							});</div>
							<p>The bicycle object has the properties <i>wheels, engine, color, and pedals</i>, and its prototype is Vehicle.prototype. The JavaScript engine finds the pedals property on bicycle, and it looks up the prototype chain to find the wheels, engine, and color properties on Vehicle.</p>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Data Properties and Accessor Properties</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>Properties determine the state of an object in JavaScript. JavaScript has three different kinds of properties: <b>named data properties, named accessor properties and internal properties.</b></li>
							<li><b>Named properties</b> are "Normal" properties of objects map string names to values.</li>
							<div class="example-div"> <span class="token">var</span> obj = {
							        prop: 123
							    };</div>
							<li>Alternatively, getting and setting a property value can be handled via functions. Those functions are called accessor functions. A function that handles getting is called a <b>getter</b>. A function that handles setting is called a <b>setter:</b></li>
							<div class="example-div"><span class="token">var</span> obj = {
						        <span class="token">get</span> <span class="keyword">prop</span>( ) {
						            return <span class="string">"Getter"</span>;
						        },
						        <span class="token">set</span> <span class="keyword">prop</span>(value) {
						            console.log(<span class="string">"Setter: "</span>+value);
						        }
						    }</div>
							<li>Some properties are only used by the specification. They are called internal, because they are not directly accessible via the language, but they do influence its behavior. Internal properties have special names that are written in double square brackets. Two examples:
								<ul class="ab-list">
									<li>The internal property <b>[[Prototype]]</b> points to the prototype of an object. It can be read via Object.getPrototypeOf( ). Its value can only be set by creating a new object that has a given prototype, e.g. via Object.create( ) or __proto__ [1].</li>
									<li>The internal property <b>[[Extensible]]</b> determines whether or not one can add properties to an object. It can be read via Object.isExtensible( ). It can be set false via Object.preventExtensions( ). Once false, it cannot be become true again.</li>
								</ul>
							</li>
							<li>There are 4 attributes for a data property.
								<ul class="ab-list">
									<li><b>value</b> is the current value of the property. It's default is set to undefined.</li>
									<li><b>writable</b> determines if the property value can be modified. It can be set to either true or false with the default being false.</li>
									<li><b>enumerable</b> determines if the property can be enumerated by a for...in statement. Its defualt is set to false.</li>
									<li><b>configurable</b> determines if property attributes can be changed, and the property can be deleted. Its default is set to false.</li>
								</ul>
							</li>
							<li>A <b>property descriptor</b> encodes the attributes of a property as an object. Each of the properties of that object corresponds to an attribute. For example, the following is the descriptor of a read-only property whose value is 123:</li>
							<div class="example-div">    {
						        value: 123,
						        writable: false,
						        enumerable: true,
						        configurable: false
						    }</div>
							<p>You can achieve the same goal, immutability, via accessors. Then the descriptor looks as follows:</p>
							<div class="example-div">    {
						        <span class="token">get: function</span> ( ) { return 123 },
						        enumerable: true,
						        configurable: false
						    }</div>
						    <li>There are 4 functions allow you to work with property descriptors:</li>
						    <p>A. <b>Object.defineProperty( )</b> - allows you to create or change a property of an object and return the modified object.</p>
						    <div class="example-div"><span class="token">var</span> obj = Object.<span class="keyword">defineProperty</span>({}, <span class="string">"foo"</span>, {
						        value: 123,
						        enumerable: true
						       <span class="comment"> // writable and configurable via defaults</span>
						    });</div>
						    <p>B. <b>Object.defineProperties( )</b> - is the batch version of Object.defineProperty( ). The names of the properties and their values tell Object.defineProperties what properties to create or change on obj.</p>
						    <div class="example-div"><span class="token">var</span> obj = Object.<span class="keyword">defineProperties</span>({}, {
						        foo: { value: 123, enumerable: true },
						        bar: { value: <span class="string">"abc"</span>, enumerable: true }
						    });</div>
						    <p>C. <b>Object.create( )</b> - creates an object with a prototype. Then, if the optional parameter propDescObj has been specified, add properties to it &ndash; in the same manner as Object.defineProperties and then returns the result. </p>
						    <div class="example-div"><span class="token">var</span> obj = Object.<span class="keyword">create</span>(Object.prototype, {
						        foo: { value: 123, enumerable: true },
						        bar: { value: <span class="string">"abc"</span>, enumerable: true }
						    });</div>
						    <p>4. <b>Object.getOwnPropertyDescriptor( )</b> - Returns the descriptor of the own (non-inherited) property of obj whose name is propName. If there is no such property, undefined is returned.</p>
						    <div class="example-div">Object.<span class="keyword">getOwnPropertyDescriptor</span>(Object.prototype, <span class="string">"toString"</span>)
							    { value: [Function: toString],
							      writable: true,
							      enumerable: false,
							      configurable: true }
							     Object.<span class="keyword">getOwnPropertyDescriptor</span>({}, <span class="string">"toString"</span>)
							    undefined</div>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Variable Scope</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>JavaScript has two scopes: <b>global</b> and <b>local</b>. A variable that is declared outside a function definition is a global variable, and its value is accessible and modifiable throughout your program. A variable that is declared inside a function definition is local. It is created and destroyed every time the function is executed, and it cannot be accessed by any code outside the function. </li>
							<li>In JavaScript, variables are evaluated as if they were declared at the beginning of the scope they exist in. Sometimes this results in unexpected behavior, as shown here:</li>
							<div class="example-div"><span class="token">var</span> aNumber = 100;  
								tweak( );  
								<span class="token">function</span> tweak( ){  
								    <span class="comment">// This prints "undefined", because aNumber is also defined locally below.  </span>
								    document.<span class="keyword">write</span>(aNumber);  
								    if (false)  
								    {  
								        <span class="token">var</span> aNumber = 123;    
								    }  
								}  </div>
							<li>JavaScript processes all variable declarations before executing any code, whether the declaration is inside a conditional block or other construct. Once JavaScript has found all the variables, it executes the code in the function. If a variable is implicitly declared inside a function - that is, if it appears on the left side of an assignment expression but has not been declared with var - it is created as a global variable.</li>
							<li>Another term for local scope is a <b>Lexical Environment</b>. A Lexical Environment is the environment of the function where it is written. That is, the static order/place where it is situated, regardless from where it is called from.</li>
							<li><b>Scope</b> refers to where variables and functions are accessible, and in what context it is being executed. Basically, a variable or function can be defined in a global or local scope. Variables have so-called function scope, and functions have the same scope as variables.</li>
							<li>A <b>closure</b> gives you access to an outer function's scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. To use a closure, simply define a function inside another function and expose it. To expose a function, return it or pass it to another function. This is made possible by referencing it to its surrounding state (the lexical environment).</li>
						    <p>Here is a good example of closure that is explained below:</p>
							<div class="example-div"><span class="token">function</span> <span class="keyword">numberGenerator</span>( ) {
								 <span class="comment"> // Local "free" variable that ends up within the closure</span>
								  <span class="token">var</span> num = 1;
								  <span class="token">function</span> <span class="keyword">checkNumber</span>( ) { 
								    console.log(num);
								  }
								  num++;
								  return <span class="keyword">checkNumber</span>;
								}
								<span class="token">var</span> number = <span class="keyword">numberGenerator</span>( );
								<span class="keyword">number</span>( ); <span class="comment">// 2</span></div>
							<p>In the example above, the function numberGenerator creates a local "free" variable num (a number) and checkNumber (a function which prints num to the console). The function checkNumber doesn't have any local variables of its own &ndash; however, it does have access to the variables within the outer function, numberGenerator, because of a closure. Therefore, it can use the variable num declared in numberGenerator to successfully log it to the console even after numberGenerator has returned.</p>
							<li>One of the most important and common uses of closure is to give objects <b>data privacy</b>. Data privacy is an essential property that helps us program to an interface, not an implementation. This is an important concept that helps us build more robust software because implementation details are more likely to change in breaking ways than interface contracts. In simple terms, this means that closure limits the scope of the information to each function range and therefore ensures that the data does not get mixed up with the other components of the program. </li>
							<li>A closure is created when you define a function &ndash; not when you execute it. Then, every time you execute that function, its already-defined closure gives it access to all the function scopes available around it. On the contrast, scopes have a lifetime. When you call a function, you create a scope during the execution of that function. Then that scope goes away. When you call the function a second time, you create a new different scope during the second execution. Then this second scope goes away as well.</li>
							<li>Another very important concept to understand when dealing with variables and scopes is <b>hoisting</b>. Hoisting is JavaScript's default behavior of moving declarations to the top. In JavaScript, a variable can be declared after it has been used. In other words; a variable can be used before it has been declared:</li>
							<p>Example 1 gives the same result as Example 2:</p>
							<div class="example-div"><span class="comment">// Example 1</span>
									x = 5; <span class="comment">// Assign 5 to x</span>
									elem = document.<span class="keyword">getElementById</span>(<span class="string">"demo"</span>); <span class="comment">// Find an element </span>
									elem.innerHTML = x;                     <span class="comment">// Display x in the element</span>
									<span class="token">var</span> x; <span class="comment">// Declare x</span>
									<span class="comment">// Example 2</span>
									<span class="token">var</span> x; <span class="comment">// Declare x</span>
									x = 5; <span class="comment">// Assign 5 to x</span>
									elem = document.<span class="keyword">getElementById</span>(<span class="string">"demo"</span>); <span class="comment">// Find an element</span>
									elem.<span class="keyword">innerHTML</span> = x;                     <span class="comment">// Display x in the element</span></div>
							<p>However, it should be noted that JavaScript only hoists declarations, not initializations. Meaning, that it hoists only declaring a variable without initializing it's value (making it equal to something).</p>
							<p>In this instance, Example 1 does <b>not</b> give the same result as Example 2:</p>
						    <div class="example-div"><span class="comment">// Example 1</span>
								<span class="token">var</span> x = 5; <span class="comment">// Initialize x</span>
								<span class="token">var</span> y = 7; <span class="comment">// Initialize y</span>
								elem = document.<span class="keyword">getElementById</span>(<span class="string">"demo"</span>); <span class="comment">// Find an element </span>
								elem.innerHTML = x + " " + y;           <span class="comment">// Display x and y</span>
								<span class="comment">// Example 2</span>
								<span class="token">var</span> x = 5; <span class="comment">// Initialize x</span>
								elem = document.<span class="keyword">getElementById</span>(<span class="string">"demo"</span>); <span class="comment">// Find an element </span>
								elem.innerHTML = x + " " + y;           <span class="comment">// Display x and y</span>
								<span class="token">var</span> y = 7; <span class="comment">// Initialize y</span></div>
						    <li>To avoid bugs, always declare all variables at the beginning of every scope.</li>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">"This" Keyword</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>When a function is created, a keyword called "this" is created (behind the scenes), which links to the object in which the function operates. Said another way, this is available to the scope of its function, yet is a reference to the object of which that function is a property/method. We use "this" similar to the way we use pronouns in natural languages like English and French. We write, "John is running fast because he is trying to catch the train." The "this" keyword not only refers to the object but it also contains the value of the object.</li>
							<li>What "this" refers to depends on where and how the function that is being executed is called. Identifying where the function is called (the "call-site") will help you determine what "this" refers to.<br> There are only four different scenarios to remember:
								<ul class="ab-list">
									<li><b>Default Binding:</b> When calling a function in a standard way, "this" will actually refer to the Global object. In the browser the Global object means the Window object. One exception to remember is if strict mode is enabled. By writing <b>"use-strict"</b> you can prevent anything from being declared on the global object.</li>
									<div class="example-div"><span class="token">function</span> <span class="keyword">foo</span>( ) {
											this.a = <span class="string">'foo'</span>
											console.log(this);
										}
											<span class="keyword">foo</span>( );
											<span class="comment">// this will log Window Object</span>
									</div>
									<li><b>Implicit Binding: </b>If the function is contained within an object then that object will will be referenced by "this". In the example below the object foo holds a reference to bar. foo will thus be logged out when bar writes "this" to the console.</li>
									<div class="example-div"><span class="token">function</span> <span class="keyword">bar</span>( ) {
											console.log(<span class="keyword">this</span>);
										}
										<span class="token">var</span>	<span class="keyword">foo</span> = {
											a: <span class="string">'foo'</span>,
											b: bar
										}
										<span class="keyword">foo</span>.b( );
										<span class="comment">// this will log the foo object</span> 
									</div>
									<li><b>Explicit Binding:</b> <b>bind, apply and call</b> are all methods that can be used to explicitly set the value of "this". The differences between these three methods will be explained below.</li>
									<div class="example-div"><span class="token">function</span> <span class="keyword">bar</span>( ) {
											console.log(<span class="keyword">this</span>);
										}
										<span class="token">var</span>	<span class="keyword">foo</span> = {
											a: <span class="string">'foo'</span>,
										}
										<span class="keyword">bar</span>.bind(foo)( );
										<span class="keyword">bar</span>.call(foo);
										<span class="keyword">bar</span>.apply(foo);
										<span class="comment">// this will log the foo object</span>
									</div>
									<li><b>New Binding:</b> When an instance of an object is created using the <b>new</b> keyword, "this" is always set to that same instance. Therefore, in this example, an instance of foo called bar has foo referenced by "this"</li>
									<div class="example-div"><span class="token">function</span> <span class="keyword">foo</span>( ) {
											<span class="keyword">this</span>.a = 'a';
											<span class="keyword">this</span>.log = function ( ) { 
											  console.log(<span class="keyword">this</span>);
											}
										}
										<span class="token">var</span> bar = <span class="token">new</span> <span class="keyword">foo</span>( );
										<span class="keyword">bar</span>.log( );
										<span class="comment">// this will log the foo object</span> 
									</div>
								</ul>
							</li>
							<li>The <b>call.( ), apply.( ), and bind.( )</b> methods are very similar in that they all attach the scope of "this" to a function or object. The key differences are:
								<ul class="ab-list">
									<li><b>call.( )</b> attaches "this" into function and executes the function immediately:</li>
										<div class="example-div"><span class="token">var</span> person = {  
											  name: <span class="string">"James Smith"</span>,
											  hello: <span class="token">function</span>(thing) {
											    console.log(<span class="keyword">this</span>.name + " says hello " + thing);
											  }
											}

											person.hello(<span class="string">"world"</span>);  <span class="comment">// output: "James Smith says hello world"</span>
											person.hello.<span class="keyword">call</span>({ name: "Jim Smith" }, <span class="string">"world"</span>); <span class="comment">// output: "Jim Smith says hell</span>
										</div>
									<li><b>apply.( )</b> is similar to call.( ) except that it takes an array-like object instead of listing the arguments out one at a time:</li>
									<div class="example-div"><span class="token">function</span> <span class="keyword">personContainer</span>( ) {
										  <span class="token">var</span> person = {  
										     name: <span class="string">"James Smith"</span>,
										     hello: <span class="token">function</span>( ) {
										       console.log(<span class="keyword">this</span>.name + " says hello " + arguments[1]);
										     }
										  }
										  person.hello.<span class="keyword">apply</span>(person, arguments);
										}
										<span class="keyword">personContainer</span>(<span class="string">"world"</span>, <span class="string">"mars"</span>); <span class="comment">// output: "James Smith says hello mars", note: arguments[0] = "world" , arguments[1] = "mars"</span>
									</div>
									<li><b>bind.( )</b> attaches "this" into a function and it needs to be invoked separately (meaning the function is NOT called immediately, just gets set up) like this:</li>
									<div class="example-div"><span class="token">var</span> person = {  
										name: <span class="string">"James Smith"</span>,
										hello: <span class="token">function</span>(thing) {
										    console.log(<span class="keyword">this</span>.name + " says hello " + thing);
										  }
										}

										person.hello(<span class="string">"world"</span>);  <span class="comment">// output: "James Smith says hello world"</span>
										<span class="token">var</span> helloFunc = person.hello.<span class="keyword">bind</span>({ name: <span class="string">"Jim Smith"</span> });
										<span class="keyword">helloFunc</span>(<span class="string">"world"</span>);  <span class="comment">// output: Jim Smith says hello world"</span>
									</div>
								</ul>
							</li>
							<li>When a function is used as an <b>event handler</b>, its "this" is set to the element the event fired from. This is very helpful for precision because it limits the event handlers function to the element called only. In this way, "this" is more effective than just DRY.</li>
							<li><b>Function Currying</b>, also known as <b>partial function application</b>, is the use of a function (that accept one or more arguments) that returns a new function with some of the arguments already set. The function that is returned has access to the stored arguments and variables of the outer function. We can use the <b>bind.( )</b> curry (preset one or more of the parameters) a function:</li>
							<div class="example-div"><span class="token">function</span> <span class="keyword">greet</span> (gender, age, name) {
					                <span class="token">var</span> salutation = gender === <span class="string">"male"</span> ? <span class="string">"Mr. "</span> : <span class="string">"Ms. "</span>;
					                if (age > 25) {
					                    return "Hello, " + salutation + name + ".";
					                }
					                else {
					                    return "Hey, " + name + ".";
					                }
					            }
						        <span class="token">var</span> greetAnAdultMale = greet.<span class="keyword">bind</span> (null, "male", 45); <br>greetAnAdultMale (<span class="string">"John Hartlove"</span>); <span class="comment">// "Hello, Mr. John Hartlove."</span> <br><span class="token">var</span> greetAYoungster = greet.bind (null, "", 16);<br>greetAYoungster (<span class="string">"Alex"</span>) <span class="comment">// "Hey, Alex."</span><br>greetAYoungster (<span class="string">"Emma Waterloo"</span>) <span class="comment">// "Hey, Emma Waterloo."</span>
							</div>
							<li>The bind.( ) method is also very useful in cases where the "this" is interrupted when a function is called within another function and creates a different scope within it's block. This is very common when using the <b>setTimeout function</b> inside a bigger function. This can be fixed with the bind.( )
							 method and is referred to as "jumping scope", meaning that we access the lexical scope of the parent function. Example:</li>
							 <div class="example-div"><span class="token">var</span> obj = {};
								obj.myMethod = <span class="token">function</span> ( ) {
								  console.log(<span class="keyword">this</span>); <span class="comment">// this = obj</span>
								    setTimeout(function ( ) {
								        console.log(<span class="keyword">this</span>); <span class="comment">// this = obj</span>
								    }.<span class="keyword">bind</span>(<span class="keyword">this</span>), 100); 
								};
								obj.myMethod( );
							 </div>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Promise Object</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>A<b>Promise Object</b> Provides a mechanism to schedule work to be done on a value that has not yet been computed. It is an abstraction for managing interactions with asynchronous APIs. The syntax is as follows:</li>
							<div class="example-div"><span class="token">var</span> promise = <span class="token">new</span> <span class="keyword">Promise</span>(<span class="token">function</span>(resolve, reject) { ... });  
							</div>
							<li>A promise object has three parameters:
								<ul class="ab-list">
									<li><b>promise</b> - Required. The variable name to which the promise is assigned.</li>
									<li><b>resolve</b> - Required. A function that runs to indicate that the promise has completed successfully.</li>
									<li><b>reject</b> - Optional. A function that runs to indicate that the promise has been rejected with an error.</li>
								</ul>
							</li>
							<li>Here is a basic example of a promise object using reject and resolve:</li>
							<div class="example-div"><span class="token">var</span> p = <span class="token">new</span> <span class="keyword">Promise</span>(<span class="token">function</span>(<span class="keyword">resolve</span>, <span class="keyword">reject</span>) {
										<span class="comment">// Do an async task async task and then...</span>
										if(true condition) {
											<span class="keyword">resolve</span>(<span class="string">'Success!'</span>);
										}
										else {
											<span class="keyword">reject</span>(<span class="string">'Failure!'</span>);
										}
									});
							</div>
							<li>A Promise must either be completed with a value, or it must be rejected with a reason. The <b>then method</b> of the Promise object runs when the promise is completed or rejected, whichever occurs first. If the promise is completed successfully, the fulfillment handler function of the then method runs. If the promise is rejected, the error handler function of the then method (or the <b>catch method</b> which specifies work to be done on the rejection of a promise) runs.</li>
							<li>The following example shows how to call a function (timeout) that returns a promise. The fulfillment handler of the then method runs after the 5000ms timeout period expires:</li>
							<div class="example-div"><span class="token">function</span> timeout(duration) {  
							    return <span class="token">new</span> <span class="keyword">Promise</span>(<span class="token">function</span>(resolve, reject) {  
							        setTimeout(resolve, duration);  
							    });  
							}  

							<span class="comment">// Note: This code uses arrow function syntax </span>
							<span class="token">var</span> m = <span class="keyword">timeout</span>(5000).<span class="keyword">then</span>(( ) => {  
							    console.log("done!");  
							})  

							<span class="comment">// Output (after 5 seconds):  
							// done!  </span>
							</div>
							<li>Here is a basic example structure of a Promise function that uses 'then' and 'catch':</li>
							<div class="example-div">doSomething().<span class="keyword">then</span>(<span class="token">function</span>(result) {
								  return doSomethingElse(result);
								})
								.<span class="keyword">then</span>(<span class="token">function</span>(newResult) {
								  return doThirdThing(newResult);
								})
								.<span class="keyword">then</span>(<span class="token">function</span>(finalResult) {
								  console.log(<span class="string">'Got the final result: '</span> + finalResult);
								})
								.<span class="keyword">catch</span>(failureCallback);
							</div>
						</ul> 
					</div>
				</div><!--   method div   -->

				<div class="method-div">
					<p class="method-title">Common Code Exercises</p>
					<div class="openMe">
						<ul class="one-two-list">
							<li>Write a sum method which will work properly when invoked using either syntax below:</li>
							<div class="example-div">console.log(<span class="keyword">sum</span>(2,3));   <span class="comment">// Outputs 5</span>
							console.log(<span class="keyword">sum</span>(2)(3));  <span class="comment">// Outputs 5</span>  
							</div>
							<p>One method would be:</p>
							<div class="example-div"><span class="token">function</span> <span class="keyword">sum</span>(x) {
							  if (arguments.length == 2) {
							    return arguments[0] + arguments[1];
							  } else {
							    return <span class="token">function</span>(y) { return x + y; };
							  }
							}</div>
							<p>Another method would be:</p>
							<div class="example-div"><span class="token">function</span> <span class="keyword">sum</span>(x, y) {
							  if (y !== undefined) {
							    return x + y;
							  } else {
							    return <span class="token">function</span>(y) { return x + y; };
							  }
							}</div>
							<li>Write a mul function which will produce the following outputs when invoked:</li>
							<div class="example-div">console.log(<span class="keyword">mul</span>(2)(3)(4));   <span class="comment">// Output: 24</span>
							console.log(<span class="keyword">mul</span>(4)(3)(4));  <span class="comment">// Outputs 48</span>  
							</div>
							<div class="example-div"><span class="token">function</span> <span class="keyword">mul</span> (x) {
								       return <span class="token">function</span> (y) { <span class="comment">// anonymous function</span>
								        return <span class="token">function</span> (z) { <span class="comment">// anonymous function </span>
								            return x * y * z; 
								        };
								    };
								}
							</div>
							<li>How do you check if an object is an array or not (without using the isArray( ) function)?</li>
							<div class="example-div">if( Object.<span class="keyword">prototype</span>.toString.<span class="keyword">call</span>( arrayList ) === <span class="string">'[object Array]'</span> ) {
								    console.log(<span class="string">'Array!'</span>);
								}
							</div>
							<li>Write a function called deepClone which takes an object and creates a object copy of it.</li>
							<div class="example-div"><span class="token">function</span> <span class="keyword">deepClone</span>(object){
								<span class="token">var</span> newObject = {};
								for(<span class="token">var</span> key in object){
									if(<span class="keyword">typeof</span> object[key] === <span class="string">'object'</span>){
									 newObject[key] = <span class="keyword">deepClone</span>(object[key]);
									}else{
									 newObject[key] = object[key];
									}
								}
								return newObject;
							}</div>
							<li>Write code for merge two JavaScript Objects dynamically.</li>
							<div class="example-div"><span class="comment">// Method 1: Using the ES6 Object assign method</span>
									<span class="token">function</span> <span class="keyword">merge</span>(toObj,fromObj){
									return Object.assign(object1,object2);
								}

								<span class="comment">// Method 2: Without using in-built function</span>
								<span class="token">function</span> <span class="keyword">merge</span>(toObj, fromObj) {
							  	if (typeof toObj === 'object' &amp;&amp; typeof fromObj === <span class="string">'object'</span>) {
							    for (<span class="token">var</span> pro in fromObj) {
							      <span class="comment">// Assign only own properties not inherited properties</span>
							      if (fromObj.hasOwnProperty(pro)) {
							       <span class="comment"> // Assign property and value</span>
							        toObj[pro] = fromObj[pro];
							      }
							    }
							  }else{
							  	throw <span class="string">"Merge function can apply only on object"</span>;
							  }
							}
							</div>
							<li>Write a function that will loop through a list of integers and print the index of each element after a 3 second delay. This is a very common question for showing you understand <b>closures</b> since the setTimeout function has access to the loop value through closure but by the time the function is set in 3 second delay, the loop has already finished and reached the end. The proper way of solving this is: </li>
							<div class="example-div"><span class="token">const</span> arr = [10, 12, 15, 21];
							for (<span class="token">var</span> i = 0; i < arr.length; i++) {
							  <span class="comment">// pass in the variable i so that each function </span>
							 <span class="comment"> // has access to the correct index</span>
							  <span class="keyword">setTimeout</span>(<span class="token">function</span>(i_local) {
							    return <span class="token">function</span>( ) {
							      console.log(<span class="string">'The index of this number is: '</span> + i_local);
							    }
							  }(i), 3000);
							}
							</div>
							<li>The famous reverse string problem:</li>
							<div class="example-div"><span class="token">function</span> solution(<span class="keyword">str</span>){
  								return <span class="keyword">str</span>.split(<span class="string">' '</span>).reverse().join(<span class="string">' '</span>);  
								}
								<span class="comment">// or in ES6 arrow function</span>
								<span class="token">const</span> solution = <span class="keyword">str</span> => <span class="keyword">str</span>.split(<span class="string">' '</span>).reverse( ).join(<span class="string">' '</span>);
							</div>
						</ul> 
					</div>
				</div><!--   method div   -->

		</div><!--  container  -->
		<script src="../jquery.min.js"></script>
	</body>
	</html>